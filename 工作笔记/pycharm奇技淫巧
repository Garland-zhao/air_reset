链式比较是可以的
In: 4>3>2>1
Out: True


使用+号连接元祖来生成一个更长的元祖, 列表同理
In: (4, None, 5) + (6, 0) + ('bar',)
Out: (4, None, 5, 6, 0, 'bar')


二分搜索和已排序列表的维护
内建的bisect模块实现了二分搜索和已排序列表的插值
bisect.bisect会找到元素应当被插入的位置, 并保持序列排序,
而bisect.insort将元素插入到相应位置

import bisect
c = [1, 2, 2, 2, 3, 4, 7]
bisect.bisect(c, 2) >>> 4
bisect.bisect(c, 5) >>> 6
bisect.bisect(c, 6)
c >>> [1, 2, 2, 2, 3, 4, 6, 7]

bisect模块的函数并不会检查列表是否已排序,
因此对未排序列表使用bisect虽然不会报错, 但是结果可能不对


使用zip拆分序列
(将行的列表转换为列的列表)
data = [('key_1', 'value_1'), ('key_2', 'value_2'), ('key_3', 'value_3')]
keys, values = zip(*data)
keys >>> ('key_1', 'key_2', 'key_3')
values >>> ('value_1', 'value_2', 'value_3')


使用reversed来生成倒序的列表
list(reversed(range(10)) >>> [9, 8, 7, ..., 2, 1]
注意: reversed()是一个生成器


字典可以接受一个2-元祖的列表作为参数
mapping = dict(zip(range(5), reversed(range(5))))
mapping >>> {0:4, 1:3, 2:2, 3:1, 4:0}


关于defaultdict

from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)




